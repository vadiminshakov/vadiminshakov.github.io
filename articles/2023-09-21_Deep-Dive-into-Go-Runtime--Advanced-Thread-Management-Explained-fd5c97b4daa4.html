<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Deep Dive into Go Runtime: Advanced Thread Management Explained</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Deep Dive into Go Runtime: Advanced Thread Management Explained</h1>
</header>
<section data-field="subtitle" class="p-summary">
Unveiling the hidden aspects of thread management in Go.
</section>
<section data-field="body" class="e-content">
<section name="7e1b" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="a7d6" id="a7d6" class="graf graf--h3 graf--leading graf--title">Deep Dive into Go Runtime: Advanced Thread Management Explained</h3><p name="0516" id="0516" class="graf graf--p graf-after--h3">Unveiling the hidden aspects of thread management in Go.</p><figure name="c6c6" id="c6c6" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*wW2W5fD8rgOz8U2sYqwHOQ.png" data-width="1024" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*wW2W5fD8rgOz8U2sYqwHOQ.png"></figure><p name="bc99" id="bc99" class="graf graf--p graf-after--figure">We all know that creating more threads than there are CPU cores on a machine is pointless. A core can only execute one task at a time. Adding more threads than cores only increases the load on the OS scheduler. Basic knowledge, yes, everyone knows that.</p><p name="2e22" id="2e22" class="graf graf--p graf-after--p">But what if I told you that having 300 threads in reserve for your Go application is beneficial? No, it’s not madness; it’s about understanding the runtime’s peculiarities.</p><p name="8451" id="8451" class="graf graf--p graf-after--p">Let’s take a step back and remember netpoll — a Go runtime abstraction for managing network requests. The task of netpoll is to register file descriptors with the OS through which we intend to read the response, send network requests, and just wait. We don’t block our own threads in any way; we simply delegate all the work to the operating system while our thread continues to execute goroutines. A goroutine performing an IO operation gets parked (taken off scheduling):</p><p name="7e2f" id="7e2f" class="graf graf--p graf-after--p"><a href="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/netpoll.go#L564" data-href="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/netpoll.go#L564" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/netpoll.go#L573</a></p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="6b3a" id="6b3a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">netpollblock</span><span class="hljs-params">(pd *pollDesc, mode <span class="hljs-type">int32</span>, waitio <span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">bool</span> {<br /> gpp := &amp;pd.rg<br /> <br /> ... lines skipped<br /><br /> <span class="hljs-keyword">if</span> waitio || netpollcheckerr(pd, mode) == pollNoError {<br />  gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceBlockNet, <span class="hljs-number">5</span>)<br /> }<br /> ... lines skipped<br />}</span></pre><p name="6004" id="6004" class="graf graf--p graf-after--pre">When a response arrives, the goroutines waiting for a network event are added to the local run queue of a thread (more precisely, a P, an abstraction above the thread, but that’s not relevant for now), and they continue their work.</p><p name="30c6" id="30c6" class="graf graf--p graf-after--p">Here’s the code that demonstrates how netpoll returns a list of goroutines that have waited for data from netpoller, which are then added to the execution queue:</p><p name="48a1" id="48a1" class="graf graf--p graf-after--p"><a href="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go#L3206" data-href="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go#L3206" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go#L3206</a></p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="go" name="0b65" id="0b65" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findRunnable</span><span class="hljs-params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="hljs-type">bool</span>) {<br /><br /> <span class="hljs-comment">// Poll network until next timer.</span><br /> <span class="hljs-keyword">if</span> netpollinited() &amp;&amp; (netpollWaiters.Load() &gt; <span class="hljs-number">0</span> || pollUntil != <span class="hljs-number">0</span>) &amp;&amp; sched.lastpoll.Swap(<span class="hljs-number">0</span>) != <span class="hljs-number">0</span> {<br />  ... lines skipped<br /><br />  list := netpoll(delay) <span class="hljs-comment">// block until new work is available</span><br />  <br />  ... lines skipped<br /><br />  lock(&amp;sched.lock)<br />  pp, _ := pidleget(now)<br />  unlock(&amp;sched.lock)<br />  <span class="hljs-keyword">if</span> pp == <span class="hljs-literal">nil</span> {<br />   injectglist(&amp;list) &lt;---- !<br />  } <span class="hljs-keyword">else</span> {<br />  <br />  ... lines skipped<br />}</span></pre><p name="54c1" id="54c1" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Intermediate Conclusion</strong>: the Go runtime doesn’t require additional threads to handle network I/O because this work is delegated to OS-specific I/O subsystems (e.g., epoll in Linux, kqueue in Darwin/FreeBSD, I/O completion ports in Windows) while goroutines are asleep (“parked”).</p><p name="384a" id="384a" class="graf graf--p graf-after--p">The bad news is that this only works for network requests. If you perform a system call unrelated to networking, such as reading or writing to a file, you can’t leverage asynchronous netpoll, <strong class="markup--strong markup--p-strong">and the thread will be blocked until the system call completes</strong>.</p><p name="aa60" id="aa60" class="graf graf--p graf-after--p">So, how does the Go runtime handle this situation? When a blocking system call is made, the thread is blocked, and a new thread is created to serve the context of the “sleeping” thread.</p><p name="1d4c" id="1d4c" class="graf graf--p graf-after--p">Please note that this is a high-level summary of how Go runtime manages I/O, and the actual implementation details are quite complex and platform-specific.</p><p name="42d5" id="42d5" class="graf graf--p graf-after--p"><a href="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go#L3206" data-href="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go#L3206" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go#</a>L2649</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="8375" id="8375" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handoffp</span><span class="hljs-params">(pp *p)</span></span> {<br /> <span class="hljs-comment">// handoffp must start an M in any situation where</span><br /> <span class="hljs-comment">// findrunnable would return a G to run on pp.</span><br /><br /> <span class="hljs-comment">// if it has local work, start it straight away</span><br /> <span class="hljs-keyword">if</span> !runqempty(pp) || sched.runqsize != <span class="hljs-number">0</span> {<br />  startm(pp, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>)<br />  <span class="hljs-keyword">return</span><br />}<br /><br />... lines skipped<br />}</span></pre><p name="a20c" id="a20c" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">Please note:</strong> system calls that cannot be handled using netpoll will spawn new OS threads if the runtime has no available threads. If there are already available threads and the Go runtime is aware of them, they will be reused.</p><p name="c2ae" id="c2ae" class="graf graf--p graf-after--p"><a href="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go#L3206" data-href="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go#L3206" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go#</a>L2563</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="acac" id="acac" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startm</span><span class="hljs-params">(pp *p, spinning, lockheld <span class="hljs-type">bool</span>)</span></span> {<br /> ... lines skipped<br /><br /> nmp := mget() &lt;---- get thread <span class="hljs-keyword">if</span> exists<br /> <span class="hljs-keyword">if</span> nmp == <span class="hljs-literal">nil</span> {<br />  id := mReserveID()<br />  unlock(&amp;sched.lock)<br /><br />  <span class="hljs-keyword">var</span> fn <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br />  <span class="hljs-keyword">if</span> spinning {<br />   <span class="hljs-comment">// The caller incremented nmspinning, so set m.spinning in the new M.</span><br />   fn = mspinning<br />  }<br />  newm(fn, pp, id) &lt;--- create a <span class="hljs-built_in">new</span> thread <span class="hljs-keyword">if</span> there is none free<br /><br />... lines skipped<br />}</span></pre><p name="8ea7" id="8ea7" class="graf graf--p graf-after--pre">This means that the more threads the runtime has, the easier it is to perform system calls. The number of CPU cores doesn’t matter in this case because it’s not about computation but rather IO work.</p><p name="dbf8" id="dbf8" class="graf graf--p graf-after--p">However, there’s an important caveat: no matter how many threads you have, they can’t do any useful work for the runtime if there are no available <code class="markup--code markup--p-code">P</code>’s. <code class="markup--code markup--p-code">P</code> is a logical context for <code class="markup--code markup--p-code">M</code> (the OS thread), and <code class="markup--code markup--p-code">M</code> can’t work without a <code class="markup--code markup--p-code">P</code>. The more P’s you create, the more you can leverage OS threads to perform tasks. The number of <code class="markup--code markup--p-code">P</code>’s is determined by the <code class="markup--code markup--p-code">GOMAXPROCS</code> variable (or <code class="markup--code markup--p-code">runtime.GOMAXPROCS()</code>). This trick was used in Dgraph:</p><p name="3716" id="3716" class="graf graf--p graf-after--p"><a href="https://groups.google.com/g/golang-nuts/c/jPb_h3TvlKE" data-href="https://groups.google.com/g/golang-nuts/c/jPb_h3TvlKE" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://groups.google.com/g/golang-nuts/c/jPb_h3TvlKE</a></p><h3 name="24ab" id="24ab" class="graf graf--h3 graf-after--p">Proof</h3><p name="009d" id="009d" class="graf graf--p graf-after--h3">I couldn’t come up with simpler system calls to use for benchmarks other than basic file read and write operations. What could be simpler? Let’s write a benchmark in which, on each iteration, we launch 100 goroutines, each of which opens a file, writes to it, and reads from it.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="go" name="d8ed" id="d8ed" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkX</span><span class="hljs-params">(b *testing.B)</span></span> {<br /> runtime.GOMAXPROCS(<span class="hljs-number">8</span>)<br /> os.Mkdir(<span class="hljs-string">&quot;./testlogdata&quot;</span>, <span class="hljs-number">0755</span>)<br /><br /> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />  <span class="hljs-keyword">var</span> g errgroup.Group<br />  <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ {<br />   g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> {<br />    suffix := strconv.Itoa(j)<br />    f, err := os.OpenFile(<span class="hljs-string">&quot;./testlogdata/ff&quot;</span>+suffix, os.O_CREATE|os.O_TRUNC|os.O_RDWR, <span class="hljs-number">0755</span>)<br />    require.NoError(b, err)<br />    f.WriteString(<span class="hljs-string">&quot;hello&quot;</span>)<br />    f.Close()<br />    os.Remove(<span class="hljs-string">&quot;./testlogdata/ff&quot;</span> + suffix)<br />    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br />   })<br />  }<br />  g.Wait()<br /> }<br /><br /> os.RemoveAll(<span class="hljs-string">&quot;./testlogdata&quot;</span>)<br />}</span></pre><p name="6349" id="6349" class="graf graf--p graf-after--pre">The second benchmark will test the same case but with a pre-set <code class="markup--code markup--p-code">GOMAXPROCS=200</code>.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="go" name="13df" id="13df" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkY</span><span class="hljs-params">(b *testing.B)</span></span> {<br /> runtime.GOMAXPROCS(<span class="hljs-number">200</span>)<br /> os.Mkdir(<span class="hljs-string">&quot;./testlogdata&quot;</span>, <span class="hljs-number">0755</span>)<br /><br /> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />  <span class="hljs-keyword">var</span> g errgroup.Group<br />  <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ {<br />   g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> {<br />    suffix := strconv.Itoa(j)<br />    f, err := os.OpenFile(<span class="hljs-string">&quot;./testlogdata/ff&quot;</span>+suffix, os.O_CREATE|os.O_TRUNC|os.O_RDWR, <span class="hljs-number">0755</span>)<br />    require.NoError(b, err)<br />    f.WriteString(<span class="hljs-string">&quot;hello&quot;</span>)<br />    f.Close()<br />    os.Remove(<span class="hljs-string">&quot;./testlogdata/ff&quot;</span> + suffix)<br />    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br />   })<br />  }<br />  g.Wait()<br /> }<br /><br /> os.RemoveAll(<span class="hljs-string">&quot;./testlogdata&quot;</span>)<br />}</span></pre><p name="d132" id="d132" class="graf graf--p graf-after--pre">Results:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="vbnet" name="2eca" id="2eca" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">go test . -run=xxx -bench=. -benchtime=<span class="hljs-number">7s</span><br /><span class="hljs-symbol">goos:</span> darwin<br /><span class="hljs-symbol">goarch:</span> amd64<br /><span class="hljs-symbol">cpu:</span> Intel(R) Core(TM) i7-<span class="hljs-number">9750</span>H CPU @ <span class="hljs-number">2.60</span>GHz<br /><br />BenchmarkX-<span class="hljs-number">12</span>               <span class="hljs-number">1280</span>           <span class="hljs-number">6180366</span> ns/op<br /><span class="hljs-symbol">testing:</span> BenchmarkX-<span class="hljs-number">12</span> left GOMAXPROCS <span class="hljs-keyword">set</span> <span class="hljs-keyword">to</span> <span class="hljs-number">8</span><br />BenchmarkY-<span class="hljs-number">12</span>               <span class="hljs-number">1776</span>           <span class="hljs-number">4738673</span> ns/op<br /><span class="hljs-symbol">testing:</span> BenchmarkY-<span class="hljs-number">12</span> left GOMAXPROCS <span class="hljs-keyword">set</span> <span class="hljs-keyword">to</span> <span class="hljs-number">200</span></span></pre><p name="4f81" id="4f81" class="graf graf--p graf-after--pre">The version with an excess of pre-created <code class="markup--code markup--p-code">P</code>’s performed <strong class="markup--strong markup--p-strong">38.75%</strong> more operations (1776 operations) than the same code with <code class="markup--code markup--p-code">GOMAXPROCS</code> set to the number of CPU cores. In reality, both versions create the same number of threads, creating a new thread for each system call.</p><p name="68ee" id="68ee" class="graf graf--p graf-after--p">So, what’s the difference? The difference lies in the fact that in the second benchmark, we create and initialize the <code class="markup--code markup--p-code">P</code> pool before starting the work, more so than in the first benchmark.</p><p name="8bc1" id="8bc1" class="graf graf--p graf-after--p">Here, you can see how the runtime initializes the number of <code class="markup--code markup--p-code">P</code>’s to be equal to <code class="markup--code markup--p-code">GOMAXPROCS</code>:</p><p name="743c" id="743c" class="graf graf--p graf-after--p"><a href="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go#L1471" data-href="https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go#L1471" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://github.com/golang/go/blob/release-branch.go1.21/src/runtime/proc.go#L1471</a></p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="59d1" id="59d1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">for</span> p1 != <span class="hljs-literal">nil</span> {<br />  p := p1<br />  p1 = p1.link.ptr()<br />  <span class="hljs-keyword">if</span> p.m != <span class="hljs-number">0</span> {<br />   mp := p.m.ptr()<br />   p.m = <span class="hljs-number">0</span><br />   <span class="hljs-keyword">if</span> mp.nextp != <span class="hljs-number">0</span> {<br />    throw(<span class="hljs-string">&quot;startTheWorld: inconsistent mp-&gt;nextp&quot;</span>)<br />   }<br />   mp.nextp.set(p)<br />   notewakeup(&amp;mp.park)<br />  } <span class="hljs-keyword">else</span> {<br />   <span class="hljs-comment">// Start M to run P.  Do not start another M below.</span><br />   newm(<span class="hljs-literal">nil</span>, p, <span class="hljs-number">-1</span>) &lt;--- start <span class="hljs-built_in">new</span> thread<br />  }<br /> }</span></pre><p name="7894" id="7894" class="graf graf--p graf-after--pre"><strong class="markup--strong markup--p-strong">What happens if the runtime creates too many threads?</strong></p><p name="ff3b" id="ff3b" class="graf graf--p graf-after--p">Unused threads get “parked.” Threads can go to sleep immediately after starting or at any point during program execution if there is no work for them. However, if you exceed the limit of 10,000 OS threads, the program will panic with a message.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="go" name="ada5" id="ada5" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">runtime: program exceeds <span class="hljs-number">10000</span>-thread limit<br />fatal <span class="hljs-type">error</span>: thread exhaustion.</span></pre><p name="77c6" id="77c6" class="graf graf--p graf-after--pre">You can increase the allowed number of threads using <code class="markup--code markup--p-code">debug.SetMaxThreads(N)</code>, but I do not recommend doing so.</p><p name="c966" id="c966" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">Conclusions:</strong></p><ul class="postList"><li name="ee35" id="ee35" class="graf graf--li graf-after--p">A large number of threads can be beneficial if a program makes many system calls.</li><li name="1ee6" id="1ee6" class="graf graf--li graf-after--li">Threads are meaningless without P, the quantity of which you can configure using GOMAXPROCS.</li><li name="3827" id="3827" class="graf graf--li graf-after--li">Network I/O doesn’t require additional threads and is performed using the asynchronous I/O facilities provided by the operating system.</li></ul><p name="7aa4" id="7aa4" class="graf graf--p graf-after--li"><em class="markup--em markup--p-em">You can support my work here: </em><a href="https://www.buymeacoffee.com/insh" data-href="https://www.buymeacoffee.com/insh" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">https://www.buymeacoffee.com/insh</em></strong></a></p><h3 name="9161" id="9161" class="graf graf--h3 graf-after--p">Stackademic</h3><p name="ea7b" id="ea7b" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">Thank you for reading until the end. Before you go:</em></p><ul class="postList"><li name="046d" id="046d" class="graf graf--li graf-after--p"><em class="markup--em markup--li-em">Please consider </em><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">clapping</em></strong><em class="markup--em markup--li-em"> and </em><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">following</em></strong><em class="markup--em markup--li-em"> the writer! 👏</em></li><li name="0d1c" id="0d1c" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">Follow us on </em><a href="https://twitter.com/stackademichq" data-href="https://twitter.com/stackademichq" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Twitter(X)</em></strong></a><em class="markup--em markup--li-em">, </em><a href="https://www.linkedin.com/company/stackademic" data-href="https://www.linkedin.com/company/stackademic" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">LinkedIn</em></strong></a><em class="markup--em markup--li-em">, and </em><a href="https://www.youtube.com/c/stackademic" data-href="https://www.youtube.com/c/stackademic" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">YouTube</em></strong></a><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">.</em></strong></li><li name="63c6" id="63c6" class="graf graf--li graf-after--li graf--trailing"><em class="markup--em markup--li-em">Visit </em><a href="http://stackademic.com/" data-href="http://stackademic.com/" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--li-strong"><em class="markup--em markup--li-em">Stackademic.com</em></strong></a><em class="markup--em markup--li-em"> to find out more about how we are democratizing free programming education around the world.</em></li></ul></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@vadiminshakov" class="p-author h-card">Vadim Inshakov</a> on <a href="https://medium.com/p/fd5c97b4daa4"><time class="dt-published" datetime="2023-09-21T12:49:53.160Z">September 21, 2023</time></a>.</p><p><a href="https://medium.com/@vadiminshakov/deep-dive-into-go-runtime-advanced-thread-management-explained-fd5c97b4daa4" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on January 21, 2024.</p></footer></article></body></html>
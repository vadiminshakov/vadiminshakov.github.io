<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Go: when pointers hide the benefits of CPU caching</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Go: when pointers hide the benefits of CPU caching</h1>
</header>
<section data-field="subtitle" class="p-summary">
Abstract: Using small-sized variables by value can be faster than using pointers due to CPU value caching.
</section>
<section data-field="body" class="e-content">
<section name="f6bb" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="bf82" id="bf82" class="graf graf--h3 graf--leading graf--title">Go: when pointers hide the benefits of CPU caching</h3><h4 name="20c6" id="20c6" class="graf graf--h4 graf-after--h3 graf--subtitle">Abstract: Using small-sized variables by value can be faster than using pointers due to CPU value caching.</h4><figure name="3173" id="3173" class="graf graf--figure graf-after--h4"><img class="graf-image" data-image-id="1*8Kiqnwfi7HRRpulPj4ju4A.png" data-width="1024" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*8Kiqnwfi7HRRpulPj4ju4A.png"></figure><blockquote name="5242" id="5242" class="graf graf--blockquote graf-after--figure">Disclaimer: Beware of premature optimizations; this article provides you with a more comprehensive understanding of the tool you are working with, rather than a silver bullet.</blockquote><p name="053e" id="053e" class="graf graf--p graf-after--blockquote">Often we use pointers when working with structures. For example, here is a code snippet that is quite familiar to you:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="ddc1" id="ddc1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> {<br />  name <span class="hljs-type">string</span><br />  age <span class="hljs-type">uint</span><br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> Name() <span class="hljs-type">string</span> {<br />  <span class="hljs-keyword">return</span> u.name<br />}</span></pre><p name="635f" id="635f" class="graf graf--p graf-after--pre">We often use the <code class="markup--code markup--p-code">(*Struct)</code> syntax for receivers, as in this example, even though in this case, we don’t need a pointer since we aren’t planning to modify the <code class="markup--code markup--p-code">User</code> structure. So why do we do it? Because we’ve been taught that working with pointers is much faster than working with values, which is true in most cases. But not always.</p><p name="5bd6" id="5bd6" class="graf graf--p graf-after--p">You’ve probably heard about processor cache lines. This is a small-sized memory that is orders (even tens of times) faster than main memory. Any data you work with is cached by the processor to optimize operations.</p><p name="cf01" id="cf01" class="graf graf--p graf-after--p">Here are the cache lines (different levels of processor cache) on my Mac:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="makefile" name="ed23" id="ed23" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">sudo sysctl -a | grep cache<br /><br />...<br /><br /><span class="hljs-section">hw.l1icachesize: 32768</span><br /><span class="hljs-section">hw.l1dcachesize: 32768</span><br /><span class="hljs-section">hw.l2cachesize: 262144</span><br /><span class="hljs-section">hw.l3cachesize: 12582912</span></span></pre><p name="77e9" id="77e9" class="graf graf--p graf-after--pre">These are byte values. Now let’s imagine that our structure fits into L1 cache. Does it make sense to cache the pointer? If the cache contains the pointer, caching doesn’t provide much benefit when accessing a field of the structure that the pointer points to. After fetching the pointer that points to a location in main memory, you’ll still need to access the main memory to retrieve the data. Consequently, <em class="markup--em markup--p-em">it’s much more advantageous to pass small structures by value</em>.</p><p name="169b" id="169b" class="graf graf--p graf-after--p">For instance, consider having the following structure:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="cfe3" id="cfe3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> Small <span class="hljs-keyword">struct</span> {<br />  str <span class="hljs-type">string</span> <span class="hljs-comment">// 16 bytes</span><br />  i   <span class="hljs-type">int</span>    <span class="hljs-comment">// 8 bytes</span><br />  b   <span class="hljs-type">bool</span>   <span class="hljs-comment">// 1 byte + 7 padding bytes</span><br />}</span></pre><p name="610e" id="610e" class="graf graf--p graf-after--pre">This structure occupies only 32 bytes in memory. And it will fit into L1! Consequently, it’s advantageous to access it without using a pointer. Let’s verify this.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="4407" id="4407" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkValue_L1</span><span class="hljs-params">(b *testing.B)</span></span> {<br /> s := Small{<span class="hljs-string">&quot;str&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>} <span class="hljs-comment">// 32 bytes, fits L1 cache</span><br /> <span class="hljs-built_in">println</span>(unsafe.Sizeof(s), unsafe.Offsetof(s.str), unsafe.Offsetof(s.i), unsafe.Offsetof(s.b))<br /><br /> <span class="hljs-comment">// prepare data</span><br /> items := <span class="hljs-built_in">make</span>([]Small, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br /> <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ {<br />  items = <span class="hljs-built_in">append</span>(items, s)<br /> }<br /><br /> <span class="hljs-comment">// bench</span><br /> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />  processSmallByVal(items) <br /> }<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPointer_L1</span><span class="hljs-params">(b *testing.B)</span></span> {<br /> s := &amp;Small{<span class="hljs-string">&quot;str&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>} <span class="hljs-comment">// 32 bytes, fits L1 cache</span><br /><br /> <span class="hljs-comment">// prepare data</span><br /> items := <span class="hljs-built_in">make</span>([]*Small, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br /> <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ {<br />  items = <span class="hljs-built_in">append</span>(items, s)<br /> }<br /><br /> <span class="hljs-comment">// bench</span><br /> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />  processSmallByPointer(items)<br /> }<br />}<br /><br /><span class="hljs-comment">/* data manipulation */</span><br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processSmallByVal</span><span class="hljs-params">(items []Small)</span></span> {<br /> <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items { <span class="hljs-comment">// get item value, item var reused to store values from slice</span><br />  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++ {<br />   item.i = i                                             <span class="hljs-comment">// access item&#x27;s field from cache, mutate field, store in cache line directly</span><br />   item.str = <span class="hljs-string">&quot;123&quot;</span>                                       <span class="hljs-comment">// same</span><br />   someint, somestr, somebool := item.i, item.str, item.b <span class="hljs-comment">// read item&#x27;s fields from cache</span><br />   _, _, _ = someint, somestr, somebool                   <span class="hljs-comment">// stub</span><br />  }<br /> }<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processSmallByPointer</span><span class="hljs-params">(items []*Small)</span></span> {<br /> <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items { <span class="hljs-comment">// get pointer, store in &#x27;item&#x27;</span><br />  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++ {<br />   item.i = i                                             <span class="hljs-comment">// go to the main mem</span><br />   item.str = <span class="hljs-string">&quot;123&quot;</span>                                       <span class="hljs-comment">// go to the main mem again</span><br />   someint, somestr, somebool := item.i, item.str, item.b <span class="hljs-comment">// go to the main mem again</span><br />   _, _, _ = someint, somestr, somebool                   <span class="hljs-comment">// stub</span><br />  }<br /> }<br />}</span></pre><p name="5593" id="5593" class="graf graf--p graf-after--pre">Results:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="c8d7" id="c8d7" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">go <span class="hljs-built_in">test</span> -bench=. -benchtime=10s<br />goos: darwin<br />goarch: amd64<br />pkg: module05/fibonachi<br />cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz<br /><br />BenchmarkValue_L1-12               44923            257923 ns/op<br />BenchmarkPointer_L1-12             15602            775480 ns/op</span></pre><p name="39e7" id="39e7" class="graf graf--p graf-after--pre">Directly accessing the value without using a pointer <strong class="markup--strong markup--p-strong">is three times faster</strong>.</p><p name="b77e" id="b77e" class="graf graf--p graf-after--p">If we increase the size of our structure to be larger than 32kb but smaller than 262,144kb, then we will be working with values from L2.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="e4ef" id="e4ef" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> Big <span class="hljs-keyword">struct</span> {<br />   arr [<span class="hljs-number">5000</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 40kb</span><br />}</span></pre><p name="bba5" id="bba5" class="graf graf--p graf-after--pre">This structure is too large for L1 on my machine but fits into L2. Let’s write a similar benchmark:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="8f8c" id="8f8c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkValue_L2</span><span class="hljs-params">(b *testing.B)</span></span> {<br />   a := [<span class="hljs-number">5000</span>]<span class="hljs-type">int</span>{} <span class="hljs-comment">// 40kb, fits L2 cache</span><br />   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ {<br />      a[i] = i <span class="hljs-comment">// fill array with values</span><br />   }<br />   s := Big{arr: a}<br /><br />   <span class="hljs-comment">// bench</span><br />   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />      processBigByVal(s)<br />   }<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPointer_L2</span><span class="hljs-params">(b *testing.B)</span></span> {<br />   a := [<span class="hljs-number">5000</span>]<span class="hljs-type">int</span>{} <span class="hljs-comment">// 40kb, fits L2 cache</span><br />   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ {<br />      a[i] = i<br />   }<br />   s := &amp;Big{arr: a}<br /><br />   <span class="hljs-comment">// bench</span><br />   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />      processBigByPointer(s)<br />   }<br />}<br /><br /><span class="hljs-comment">/* data manipulation */</span><br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processBigByVal</span><span class="hljs-params">(item Big)</span></span> {<br /> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ {<br />  item.arr[i] = i<br />  somearr := item.arr<br />  _ = somearr<br /> }<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processBigByPointer</span><span class="hljs-params">(item *Big)</span></span> {<br /> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ {<br />  item.arr[i] = i<br />  somearr := item.arr<br />  _ = somearr<br /> }<br />}</span></pre><p name="b574" id="b574" class="graf graf--p graf-after--pre">Results:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="8ec4" id="8ec4" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">go <span class="hljs-built_in">test</span> -bench=. -benchtime=1s<br /><br />BenchmarkValue_L2-12              502042              2396 ns/op<br />BenchmarkPointer_L2-12            468314              2855 ns/op</span></pre><p name="98b9" id="98b9" class="graf graf--p graf-after--pre">The results are nearly identical. As you may have noticed, this time I used <code class="markup--code markup--p-code">-benchtime=1s</code> instead of 10s, as before, because the longer the benchmark time, the more iterations with the function call <code class="markup--code markup--p-code">processBigByVal(s)</code> will occur. Now that we have a relatively large structure, copying it when passing to the function starts to overshadow all the benefits of accessing the value from the cache (what happens inside the function). Copying a pointer is easier than copying a structure because it&#39;s smaller. The larger the size of the structures we use, the less efficient the cache becomes for our values, and the more expensive it becomes to pass such values to functions and methods.</p><p name="9cae" id="9cae" class="graf graf--p graf-after--p">Finally, let’s see what happens when the structure is larger than L3.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="bce9" id="bce9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> VeryBig <span class="hljs-keyword">struct</span> {<br />   arr [<span class="hljs-number">500000</span>]<span class="hljs-type">int</span><br />}</span></pre><p name="4a24" id="4a24" class="graf graf--p graf-after--pre">In this case, accessing main memory through a pointer is much cheaper (98 times faster):</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="5267" id="5267" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">BenchmarkValue_MainMem-12            318           3207093 ns/op<br />BenchmarkPointer_MainMem-12        35938             32765 ns/op</span></pre><p name="dccb" id="dccb" class="graf graf--p graf-after--pre">Therefore, if you are dealing with small-sized entities, you can consider removing pointers. Besides the potential performance gain from efficient CPU cache utilization, you will also reduce the load on the garbage collector, which will have to clean up fewer objects in the heap.</p><p name="16f6" id="16f6" class="graf graf--p graf-after--p">Full source code of benchmarks:<br><a href="https://gist.github.com/vadimInshakov/c938a913628e21cb282080f6c190ef06" data-href="https://gist.github.com/vadimInshakov/c938a913628e21cb282080f6c190ef06" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://gist.github.com/vadimInshakov/c938a913628e21cb282080f6c190ef06</a></p><p name="bd3b" id="bd3b" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">You can support my work here: </em><a href="https://www.buymeacoffee.com/insh" data-href="https://www.buymeacoffee.com/insh" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">https://www.buymeacoffee.com/insh</em></strong></a></p><p name="f057" id="f057" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">Thank you for reading until the end. Please consider following the writer and this publication. Visit </em><a href="https://stackademic.com/" data-href="https://stackademic.com/" class="markup--anchor markup--p-anchor" rel="noopener noreferrer noopener" target="_blank"><em class="markup--em markup--p-em">Stackademic</em></a><em class="markup--em markup--p-em"> to find out more about how we are democratizing free programming education around the world.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@vadiminshakov" class="p-author h-card">Vadim Inshakov</a> on <a href="https://medium.com/p/1e290fc30077"><time class="dt-published" datetime="2023-08-19T11:08:17.019Z">August 19, 2023</time></a>.</p><p><a href="https://medium.com/@vadiminshakov/go-when-pointers-reduce-the-impact-of-cpu-caching-1e290fc30077" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on January 21, 2024.</p></footer></article></body></html>
<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Go: когда указатели снижают эффект от CPU-кеширования</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Go: когда указатели снижают эффект от CPU-кеширования</h1>
</header>
<section data-field="subtitle" class="p-summary">
Абстракт: использование переменных небольшого размера по значению может быть быстрее, чем по указателю, благодаря кешированию значения…
</section>
<section data-field="body" class="e-content">
<section name="7a8c" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2030" id="2030" class="graf graf--h3 graf--leading graf--title">Go: когда указатели снижают эффект от CPU-кеширования</h3><p name="6003" id="6003" class="graf graf--p graf-after--h3"><em class="markup--em markup--p-em">Абстракт: использование переменных небольшого размера по значению может быть быстрее, чем по указателю, благодаря кешированию значения процессором.</em></p><figure name="3702" id="3702" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*IG1DAVQ0r0-lDBS8qg83jg.png" data-width="1024" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*IG1DAVQ0r0-lDBS8qg83jg.png"></figure><blockquote name="86e8" id="86e8" class="graf graf--blockquote graf-after--figure">Дисклеймер: остерегайтесь преждевременных оптимизаций; эта статья дает вам лишь более полное понимание инструмента, с которым вы работаете, а не серебряную пулю.</blockquote><p name="136c" id="136c" class="graf graf--p graf-after--blockquote">Нередко мы не задумываясь используем указатели при работе со структурами. Например, вот довольно привычный нам код:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="8341" id="8341" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> {<br />  name <span class="hljs-type">string</span><br />  age <span class="hljs-type">uint</span><br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> Name() <span class="hljs-type">string</span> {<br />  <span class="hljs-keyword">return</span> u.name<br />}</span></pre><p name="f98a" id="f98a" class="graf graf--p graf-after--pre">Мы часто используем <code class="markup--code markup--p-code">(*Struct)</code> синтаксис для ресиверов, как в этом примере, хотя в данном случае нам не нужен указатель, ведь мы не собираемся никак менять структуру User. Почему мы тогда так делаем? Потому что нас учили, что работа с указателями намного быстрее, чем с самими значениями. И это в большинстве случаев правда. Но не всегда.</p><p name="b43a" id="b43a" class="graf graf--p graf-after--p">Вы наверняка слышали о кеш-линиях процессора. Это память небольшого размера, которая на порядки (и даже в десятки раз) быстрее основной памяти. Любые данные, с которыми вы работаете, кешируются процессором для оптимизации работы.</p><p name="2552" id="2552" class="graf graf--p graf-after--p">Вот кеш-линии (разные уровни кеша процессора) на моем Mac:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="makefile" name="1012" id="1012" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">sudo sysctl -a | grep cache<br /><br />...<br /><br /><span class="hljs-section">hw.l1icachesize: 32768</span><br /><span class="hljs-section">hw.l1dcachesize: 32768</span><br /><span class="hljs-section">hw.l2cachesize: 262144</span><br /><span class="hljs-section">hw.l3cachesize: 12582912</span></span></pre><p name="db95" id="db95" class="graf graf--p graf-after--pre">Это значения в байтах. Теперь давайте представим, что наша структура помещается в L1. Имеет ли смысл <em class="markup--em markup--p-em">кешировать указатель</em>? Если в кеше лежить указатель, то при обращении к полю структуры, на которую указывает указатель, кеширование не имеет смысла: после извлечения указателя, указывающего на место в основной памяти, вам придется идти в основную память для извлечения данных. Следовательно, <em class="markup--em markup--p-em">гораздо выгоднее передавать маленькие структуры по значению</em>.</p><p name="ac61" id="ac61" class="graf graf--p graf-after--p">Скажем, у вас есть такая структура:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="3b81" id="3b81" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> Small <span class="hljs-keyword">struct</span> {<br />  str <span class="hljs-type">string</span> <span class="hljs-comment">// 16 bytes</span><br />  i   <span class="hljs-type">int</span>    <span class="hljs-comment">// 8 bytes</span><br />  b   <span class="hljs-type">bool</span>   <span class="hljs-comment">// 1 byte + 7 padding bytes</span><br />}</span></pre><p name="8b03" id="8b03" class="graf graf--p graf-after--pre">Эта структура занимает в памяти всего 32 байта. И она поместится в L1! Следовательно, к ней выгодно обращаться без указателя. Давайте это проверим.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="f57c" id="f57c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkValue_L1</span><span class="hljs-params">(b *testing.B)</span></span> {<br /> s := Small{<span class="hljs-string">&quot;str&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>} <span class="hljs-comment">// 32 bytes, fits L1 cache</span><br /> <span class="hljs-built_in">println</span>(unsafe.Sizeof(s), unsafe.Offsetof(s.str), unsafe.Offsetof(s.i), unsafe.Offsetof(s.b))<br /><br /> <span class="hljs-comment">// prepare data</span><br /> items := <span class="hljs-built_in">make</span>([]Small, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br /> <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ {<br />  items = <span class="hljs-built_in">append</span>(items, s)<br /> }<br /><br /> <span class="hljs-comment">// bench</span><br /> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />  processSmallByVal(items) <br /> }<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPointer_L1</span><span class="hljs-params">(b *testing.B)</span></span> {<br /> s := &amp;Small{<span class="hljs-string">&quot;str&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>} <span class="hljs-comment">// 32 bytes, fits L1 cache</span><br /><br /> <span class="hljs-comment">// prepare data</span><br /> items := <span class="hljs-built_in">make</span>([]*Small, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br /> <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ {<br />  items = <span class="hljs-built_in">append</span>(items, s)<br /> }<br /><br /> <span class="hljs-comment">// bench</span><br /> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />  processSmallByPointer(items)<br /> }<br />}<br /><br /><span class="hljs-comment">/* data manipulation */</span><br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processSmallByVal</span><span class="hljs-params">(items []Small)</span></span> {<br /> <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items { <span class="hljs-comment">// get item value, item var reused to store values from slice</span><br />  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++ {<br />   item.i = i                                             <span class="hljs-comment">// access item&#x27;s field from cache, mutate field, store in cache line directly</span><br />   item.str = <span class="hljs-string">&quot;123&quot;</span>                                       <span class="hljs-comment">// same</span><br />   someint, somestr, somebool := item.i, item.str, item.b <span class="hljs-comment">// read item&#x27;s fields from cache</span><br />   _, _, _ = someint, somestr, somebool                   <span class="hljs-comment">// stub</span><br />  }<br /> }<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processSmallByPointer</span><span class="hljs-params">(items []*Small)</span></span> {<br /> <span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items { <span class="hljs-comment">// get pointer, store in &#x27;item&#x27;</span><br />  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++ {<br />   item.i = i                                             <span class="hljs-comment">// go to the main mem</span><br />   item.str = <span class="hljs-string">&quot;123&quot;</span>                                       <span class="hljs-comment">// go to the main mem again</span><br />   someint, somestr, somebool := item.i, item.str, item.b <span class="hljs-comment">// go to the main mem again</span><br />   _, _, _ = someint, somestr, somebool                   <span class="hljs-comment">// stub</span><br />  }<br /> }<br />}</span></pre><p name="1bb2" id="1bb2" class="graf graf--p graf-after--pre">Результаты:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="1adc" id="1adc" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">go <span class="hljs-built_in">test</span> -bench=. -benchtime=10s<br />goos: darwin<br />goarch: amd64<br />pkg: module05/fibonachi<br />cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz<br /><br />BenchmarkValue_L1-12               44923            257923 ns/op<br />BenchmarkPointer_L1-12             15602            775480 ns/op</span></pre><p name="6f7d" id="6f7d" class="graf graf--p graf-after--pre">Обращение со значением напрямую без указателя <strong class="markup--strong markup--p-strong">в 3 раза быстрее</strong>.</p><p name="d633" id="d633" class="graf graf--p graf-after--p">Если увеличить нашу структуру так, чтобы она была больше 32kb, но меньше 262.144kb, тогда мы будем работать со значениями из L2.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="bcc8" id="bcc8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> Big <span class="hljs-keyword">struct</span> {<br />   arr [<span class="hljs-number">5000</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 40kb</span><br />}</span></pre><p name="a2de" id="a2de" class="graf graf--p graf-after--pre">Такая структура слишком большая для L1 на моей машине, но помещается в L2. Напишем аналогичный бенчмарк:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="f065" id="f065" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkValue_L2</span><span class="hljs-params">(b *testing.B)</span></span> {<br />   a := [<span class="hljs-number">5000</span>]<span class="hljs-type">int</span>{} <span class="hljs-comment">// 40kb, fits L2 cache</span><br />   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ {<br />      a[i] = i <span class="hljs-comment">// fill array with values</span><br />   }<br />   s := Big{arr: a}<br /><br />   <span class="hljs-comment">// bench</span><br />   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />      processBigByVal(s)<br />   }<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPointer_L2</span><span class="hljs-params">(b *testing.B)</span></span> {<br />   a := [<span class="hljs-number">5000</span>]<span class="hljs-type">int</span>{} <span class="hljs-comment">// 40kb, fits L2 cache</span><br />   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ {<br />      a[i] = i<br />   }<br />   s := &amp;Big{arr: a}<br /><br />   <span class="hljs-comment">// bench</span><br />   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />      processBigByPointer(s)<br />   }<br />}<br /><br /><span class="hljs-comment">/* data manipulation */</span><br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processBigByVal</span><span class="hljs-params">(item Big)</span></span> {<br /> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ {<br />  item.arr[i] = i<br />  somearr := item.arr<br />  _ = somearr<br /> }<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">processBigByPointer</span><span class="hljs-params">(item *Big)</span></span> {<br /> <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ {<br />  item.arr[i] = i<br />  somearr := item.arr<br />  _ = somearr<br /> }<br />}</span></pre><p name="5402" id="5402" class="graf graf--p graf-after--pre">Результаты:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="c882" id="c882" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">go <span class="hljs-built_in">test</span> -bench=. -benchtime=1s<br /><br />BenchmarkValue_L2-12              502042              2396 ns/op<br />BenchmarkPointer_L2-12            468314              2855 ns/op</span></pre><p name="1e47" id="1e47" class="graf graf--p graf-after--pre">Результаты практически одинаковые. Как вы заметили, я использовал в этот раз <code class="markup--code markup--p-code">-benchtime=1s</code> , а не 10s, как в прошлый раз, потому что чем больше время бенчмарка, тем больше будет итераций с вызовом функции <code class="markup--code markup--p-code">processBigByVal(s)</code> , а поскольку теперь структура у нас относительно большая, её копирование при передаче в функцию начинает скрывать все преимущества от доступа к значению из кеша (то что происходит внутри функции). Указатель скопировать проще, чем структуру, потому что он меньше. И чем большего размера мы используем структуры, тем в менее эффективный кеш попадают наши значения и тем дороже становится передача таких значений в функции и методы.</p><p name="6822" id="6822" class="graf graf--p graf-after--p">Наконец, давайте посмотрим, что будет, если структура больше L3.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="89cd" id="89cd" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> VeryBig <span class="hljs-keyword">struct</span> {<br />   arr [<span class="hljs-number">500000</span>]<span class="hljs-type">int</span><br />}</span></pre><p name="89c9" id="89c9" class="graf graf--p graf-after--pre">И в этом случае обращаться в основную память гораздо дешевле по указателю (в 98 раз быстрее):</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="90e9" id="90e9" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">BenchmarkValue_MainMem-12            318           3207093 ns/op<br />BenchmarkPointer_MainMem-12        35938             32765 ns/op</span></pre><p name="119d" id="119d" class="graf graf--p graf-after--pre">Следовательно, если вы оперируете сущностями небольшого размера, можете попробовать убрать указатели. Кроме возможного выигрыша в производительности от эффективного использования CPU-кешей вы также снизите нагрузку на garbage collector, которому придется очищать меньше объектов в heap.</p><p name="31b4" id="31b4" class="graf graf--p graf-after--p graf--trailing">Полный исходный код бенчмарков: <a href="https://gist.github.com/vadimInshakov/c938a913628e21cb282080f6c190ef06" data-href="https://gist.github.com/vadimInshakov/c938a913628e21cb282080f6c190ef06" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://gist.github.com/vadimInshakov/c938a913628e21cb282080f6c190ef06</a></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@vadiminshakov" class="p-author h-card">Vadim Inshakov</a> on <a href="https://medium.com/p/6fd34365991b"><time class="dt-published" datetime="2023-08-19T10:42:03.623Z">August 19, 2023</time></a>.</p><p><a href="https://medium.com/@vadiminshakov/go-%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8-%D1%81%D0%BD%D0%B8%D0%B6%D0%B0%D1%8E%D1%82-%D1%8D%D1%84%D1%84%D0%B5%D0%BA%D1%82-%D0%BE%D1%82-cpu-%D0%BA%D0%B5%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-6fd34365991b" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on January 21, 2024.</p></footer></article></body></html>
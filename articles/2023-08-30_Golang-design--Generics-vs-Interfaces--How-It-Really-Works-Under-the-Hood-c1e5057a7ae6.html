<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Golang design: Generics vs Interfaces, How It Really Works Under the Hood</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Golang design: Generics vs Interfaces, How It Really Works Under the Hood</h1>
</header>
<section data-field="subtitle" class="p-summary">
A long story in simple words about how the internals of Go work when using generics and interfaces. Be the better engineer by making right…
</section>
<section data-field="body" class="e-content">
<section name="2a1b" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="be81" id="be81" class="graf graf--h3 graf--leading graf--title">Golang design: Generics vs Interfaces, How It Really Works Under the Hood</h3><blockquote name="0690" id="0690" class="graf graf--blockquote graf-after--h3">A long story in simple words about how the internals of Go work when using generics and interfaces. Be the better engineer by making right decisions.</blockquote><figure name="0501" id="0501" class="graf graf--figure graf-after--blockquote"><img class="graf-image" data-image-id="1*uT60RAQxOBNCObcd_ZRLgw.png" data-width="1024" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*uT60RAQxOBNCObcd_ZRLgw.png"></figure><p name="8561" id="8561" class="graf graf--p graf-after--figure">Sometimes you just need to have a function or method that accepts arguments with the same behavior. What to use: generics or interfaces?</p><p name="1f59" id="1f59" class="graf graf--p graf-after--p">The answer requires a deep dive into the Go’s design.</p><p name="9c11" id="9c11" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">WARN! Spoiler:</em></strong><em class="markup--em markup--p-em"> in most cases, it’s better to use interfaces, but there are cases where generics would be more optimal.</em></p><p name="26e3" id="26e3" class="graf graf--p graf-after--p">Let’s look at two examples of polymorphism.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="466d" id="466d" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> counter <span class="hljs-keyword">interface</span> {<br /> Add()<br />}<br /><br /><span class="hljs-keyword">type</span> counterImpl1 <span class="hljs-keyword">struct</span> {<br /> n <span class="hljs-type">int</span><br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p counterImpl1)</span></span> Add() {<br /> p.n++<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(p counter)</span></span> {<br /> p.Add()<br />}</span></pre><p name="b773" id="b773" class="graf graf--p graf-after--pre">The function <code class="markup--code markup--p-code">add</code> takes <code class="markup--code markup--p-code">counterImpl1</code>, which satisfies the <code class="markup--code markup--p-code">counter</code> interface and calls its method. We can do the same thing using generics:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="go" name="8c18" id="8c18" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addGeneric</span>[<span class="hljs-title">T</span> <span class="hljs-title">counter</span>]<span class="hljs-params">(p T)</span></span> {<br /> p.Add()<br />}</span></pre><p name="b61d" id="b61d" class="graf graf--p graf-after--pre">This works just like the previous example. We simply created two identical functions with a parameter that has specific methods. Is there any difference? Yes, there is.</p><h4 name="3af4" id="3af4" class="graf graf--h4 graf-after--p">Dynamic dispatch</h4><p name="2a64" id="2a64" class="graf graf--p graf-after--h4">Interfaces are based on dynamic dispatch. This means that when calling an interface method, the go runtime has to find the address of the method (a function taking an object of the type on which the method is defined) of the specific type implementing the interface. The compiler creates tables that match calls of interface methods with specific methods, with the specific methods represented as pointers. Go runtime uses these tables to get a pointer to the required method (actually a function pointer), which is dereferenced and then called. More about the structure of interfaces can be found <a href="https://research.swtch.com/interfaces" data-href="https://research.swtch.com/interfaces" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a> and <a href="https://www.tapirgames.com/blog/golang-interface-implementation" data-href="https://www.tapirgames.com/blog/golang-interface-implementation" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here</a>.</p><p name="cbe3" id="cbe3" class="graf graf--p graf-after--p">Thus, calling any interface method involves dereferencing. This is problematic because it doesn’t allow efficient use of the processor’s cache. We discussed this in more detail <a href="https://medium.com/stackademic/go-when-pointers-reduce-the-impact-of-cpu-caching-1e290fc30077" data-href="https://medium.com/stackademic/go-when-pointers-reduce-the-impact-of-cpu-caching-1e290fc30077" class="markup--anchor markup--p-anchor" target="_blank">in the previous article</a>.</p><p name="e545" id="e545" class="graf graf--p graf-after--p">Generics in Go operate based on hybrid (partial) monomorphization. What is monomorphization? Let’s find out.</p><p name="cdfc" id="cdfc" class="graf graf--p graf-after--p">Suppose you have a generic function:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="go" name="2ae1" id="2ae1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span>[<span class="hljs-title">T</span> <span class="hljs-title">int</span> | <span class="hljs-title">string</span>]<span class="hljs-params">(x, y T)</span></span> T {<br />  <span class="hljs-keyword">return</span> x + y<br />}</span></pre><p name="f919" id="f919" class="graf graf--p graf-after--pre">When you compile this code, you’ll get something like this in the resulting binary (pseudocode):</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="58c2" id="58c2" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addInt</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {<br />  <span class="hljs-keyword">return</span> x + y<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addString</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> {<br />  <span class="hljs-keyword">return</span> x + y<br />}</span></pre><p name="65a6" id="65a6" class="graf graf--p graf-after--pre">This is monomorphization: the compiler automatically generates multiple copies of your types, functions, and methods for each usage scenario. This means zero cost for the runtime, and this is mainly how generics work in compiled languages.</p><p name="e00d" id="e00d" class="graf graf--p graf-after--p">Go uses a similar technique called “GCShape stenciling with Dictionaries”. Stenciling is just a rephrased “monomorphization”. And GCShape refers to groups of types that can be interchangeably used when instantiating generic objects. “Two concrete types are in the same gcshape grouping if and only if they have the same underlying type or they are both pointer types” — this is how it’s described <a href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md" data-href="https://github.com/golang/proposal/blob/master/design/generics-implementation-dictionaries-go1.18.md" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">in the design document</a> of Go generics.</p><p name="f4f4" id="f4f4" class="graf graf--p graf-after--p">This means that if we instantiate our <code class="markup--code markup--p-code">add</code> function for the type <code class="markup--code markup--p-code">type Key string</code> and for the type <code class="markup--code markup--p-code">type Name string</code>, we only need to create one version of the <code class="markup--code markup--p-code">add</code> function during compilation because these types form one GCShape. And that’s great. But there’s a downside: all pointers form a single GCShape, which necessitates passing dictionaries to the resulting function, which contain lists of methods of those types the pointers refer to (for the same dynamic dispatch we discussed earlier).</p><p name="0196" id="0196" class="graf graf--p graf-after--p">This means that a function taking an interface and a generic <strong class="markup--strong markup--p-strong">function <em class="markup--em markup--p-em">both use dynamic dispatch</em></strong>. Only generic functions need to first retrieve type information from the dictionary, and then find its method, which adds some overhead.</p><h4 name="699b" id="699b" class="graf graf--h4 graf-after--p">Generic vs Interface</h4><p name="b4a4" id="b4a4" class="graf graf--p graf-after--h4">Let’s check how both implementations work.</p><p name="c984" id="c984" class="graf graf--p graf-after--p">We’ll create an interface and two functions (a regular one and a generic one) that work with this interface:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="go" name="dd1e" id="dd1e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> counter <span class="hljs-keyword">interface</span> {<br /> Add()<br /> Sub()<br /> Multiply()<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addsubmul</span><span class="hljs-params">(p counter)</span></span> {<br /> p.Add()<br /> p.Multiply()<br /> p.Sub()<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addsubmulGeneric</span>[<span class="hljs-title">T</span> <span class="hljs-title">counter</span>]<span class="hljs-params">(p T)</span></span> {<br /> p.Add()<br /> p.Multiply()<br /> p.Sub()<br />}</span></pre><p name="2586" id="2586" class="graf graf--p graf-after--pre">Now let’s write benchmarks:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="go" name="9346" id="9346" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkIface</span><span class="hljs-params">(b *testing.B)</span></span> {<br /> b.Run(<span class="hljs-string">&quot;ifaceByPointer&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b *testing.B)</span></span> {<br />  impl1 := &amp;counterImpl1Ptr{}<br />  impl2 := &amp;counterImpl2Ptr{}<br />  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />   <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ {<br />    addsubmul(impl1)<br />    addsubmul(impl2)<br />   }<br />  }<br /> })<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkGeneric</span><span class="hljs-params">(b *testing.B)</span></span> {<br /> b.Run(<span class="hljs-string">&quot;genericByPointer&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b *testing.B)</span></span> {<br />  impl1 := &amp;counterImpl1Ptr{}<br />  impl2 := &amp;counterImpl2Ptr{}<br />  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />   <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ {<br />    addsubmulGeneric[*counterImpl1Ptr](impl1)<br />    addsubmulGeneric[*counterImpl2Ptr](impl2)<br />   }<br />  }<br /> })<br />}</span></pre><p name="fab3" id="fab3" class="graf graf--p graf-after--pre"><em class="markup--em markup--p-em">(I added an extra 100 iterations inside the benchmark loop to get more illustrative results)</em></p><p name="9c20" id="9c20" class="graf graf--p graf-after--p">The results are roughly the same, as we expected:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="5c78" id="5c78" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">go <span class="hljs-built_in">test</span> --bench=. --benchtime=10s<br /><br />goos: darwin<br />goarch: amd64<br />pkg: module05/fibonachi<br />cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz<br />BenchmarkIface/ifaceByPointer-12        11261798               986.5 ns/op<br />BenchmarkGeneric/genericByPointer-12    11983582               996.4 ns/op</span></pre><h4 name="0d8e" id="0d8e" class="graf graf--h4 graf-after--pre">Generics are faster when passing arguments by value</h4><p name="1b87" id="1b87" class="graf graf--p graf-after--h4">I made a small main function where we initialize a structure and pass it by value to a function that takes an interface (line 39), and to a generic function.</p></div><div class="section-inner sectionLayout--outsetColumn"><figure name="1de6" id="1de6" class="graf graf--figure graf--layoutOutsetCenter graf-after--p"><img class="graf-image" data-image-id="1*R-r0MOyZH9CZ9JhACMimMg.png" data-width="2392" data-height="676" src="https://cdn-images-1.medium.com/max/1200/1*R-r0MOyZH9CZ9JhACMimMg.png"></figure></div><div class="section-inner sectionLayout--insetColumn"><p name="a865" id="a865" class="graf graf--p graf-after--figure">We see that a dictionary is being used here! But for what purpose?</p><figure name="db50" id="db50" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*XNoVuu9ocsUVZ-MFVVmqyA.png" data-width="1236" data-height="572" src="https://cdn-images-1.medium.com/max/800/1*XNoVuu9ocsUVZ-MFVVmqyA.png"></figure><p name="aabb" id="aabb" class="graf graf--p graf-after--figure">The dictionary is passed to the AX register.</p><figure name="bb46" id="bb46" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*WuKg1sd14906q-R12UZkDg.png" data-width="1568" data-height="496" src="https://cdn-images-1.medium.com/max/800/1*WuKg1sd14906q-R12UZkDg.png"></figure><p name="f403" id="f403" class="graf graf--p graf-after--figure">(1) deref method pointer from dictionary and pass it to CX register;</p><p name="07d5" id="07d5" class="graf graf--p graf-after--p">(2) call method</p><p name="f587" id="f587" class="graf graf--p graf-after--p">This is assembly for:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="css" name="16c8" id="16c8" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">func addsubmulGeneric<span class="hljs-selector-attr">[T counter]</span>(<span class="hljs-selector-tag">p</span> T) {<br /> <span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.Add</span>() &lt;--<br /> ...<br />}</span></pre><p name="8875" id="8875" class="graf graf--p graf-after--pre">And then it just repeats. For <code class="markup--code markup--p-code">p.Multiply()</code> we see this:</p><figure name="ecca" id="ecca" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*d0EuQE3vaYl8O8sCpM2ojQ.png" data-width="826" data-height="372" src="https://cdn-images-1.medium.com/max/800/1*d0EuQE3vaYl8O8sCpM2ojQ.png"></figure><p name="881a" id="881a" class="graf graf--p graf-after--figure">(1) take dictionary address from stack;</p><p name="8b5e" id="8b5e" class="graf graf--p graf-after--p">(2) deref dict address + 8 bytes offset (method Multiply);</p><p name="8579" id="8579" class="graf graf--p graf-after--p">(3) call method</p><p name="1409" id="1409" class="graf graf--p graf-after--p">Even though we passed not a pointer but a structure by value to the generic function, and <strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">it seems that the compiler could monomorphize this code, but it still uses dictionaries</em></strong>, and this should negatively impact performance.</p><p name="90d6" id="90d6" class="graf graf--p graf-after--p">Benchmark:</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="go" name="b049" id="b049" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkIface</span><span class="hljs-params">(b *testing.B)</span></span> {<br /> b.Run(<span class="hljs-string">&quot;ifaceByValue&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b *testing.B)</span></span> {<br />  impl1 := counterImpl1{}<br />  impl2 := counterImpl2{}<br />  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />   <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ {<br />    addsubmul(impl1)<br />    addsubmul(impl2)<br />   }<br />  }<br /> })<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkGeneric</span><span class="hljs-params">(b *testing.B)</span></span> {<br /> b.Run(<span class="hljs-string">&quot;genericByValue&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b *testing.B)</span></span> {<br />  impl1 := counterImpl1{}<br />  impl2 := counterImpl2{}<br />  <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />   <span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">100</span>; j++ {<br />    addsubmulGeneric[counterImpl1](impl1)<br />    addsubmulGeneric[counterImpl2](impl2)<br />   }<br />  }<br /> })<br />}</span></pre><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="7705" id="7705" class="graf graf--pre graf-after--pre graf--preV2"><span class="pre--content">go <span class="hljs-built_in">test</span> --bench=. --benchtime=10s<br /><br />goos: darwin<br />goarch: amd64<br />pkg: module5<br />cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz<br />BenchmarkIface/ifaceByValue-12           7997700              1382 ns/op<br />BenchmarkGeneric/genericByValue-12      13218322               933.3 ns/op</span></pre><p name="fa10" id="fa10" class="graf graf--p graf-after--pre">Incredibly, the generic function is faster, even though it uses the same dynamic dispatch! <strong class="markup--strong markup--p-strong">The difference is 48%</strong>.</p><p name="bcf7" id="bcf7" class="graf graf--p graf-after--p">Why?</p><figure name="e155" id="e155" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*WQ51SuzSpzbVDkSrtPwWRA.png" data-width="2360" data-height="1422" src="https://cdn-images-1.medium.com/max/800/1*WQ51SuzSpzbVDkSrtPwWRA.png"></figure><ul class="postList"><li name="aeca" id="aeca" class="graf graf--li graf-after--figure">the compiler was able to inline the generic function</li><li name="cb49" id="cb49" class="graf graf--li graf-after--li">arguments of a non-generic function are allocated on the heap</li></ul><p name="e975" id="e975" class="graf graf--p graf-after--li">The thing is, when passing by value, Go knows the specific GCShape that the generic function accepts, knows its size, and can decide to allocate it on the stack because it’s much more efficient than the heap. When using interfaces, however, you don’t have a choice but to allocate on the heap, because an interface is a pointer type.</p><h4 name="dc05" id="dc05" class="graf graf--h4 graf-after--p">Conclusion</h4><p name="e802" id="e802" class="graf graf--p graf-after--h4">Generics in Go are similar to implementations in other mainstream languages but use additional mechanisms (gcshape, dictionaries) to reduce binary sizes and compile times, <em class="markup--em markup--p-em">slightly sacrificing performance</em>. This may change in future releases of Go.</p><p name="de78" id="de78" class="graf graf--p graf-after--p">If you need a polymorphic function whose parameters are not of a pointer type, go with the generic implementation, as the compiler can better optimize it by avoiding heap allocations when possible.</p><p name="ad6b" id="ad6b" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">You can support my work here: </em><a href="https://www.buymeacoffee.com/insh" data-href="https://www.buymeacoffee.com/insh" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">https://www.buymeacoffee.com/insh</em></strong></a></p><p name="23e2" id="23e2" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">Thank you for reading until the end. Please consider following the writer and this publication. Visit </em><a href="https://stackademic.com/" data-href="https://stackademic.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Stackademic</em></strong></a><em class="markup--em markup--p-em"> to find out more about how we are democratizing free programming education around the world.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@vadiminshakov" class="p-author h-card">Vadim Inshakov</a> on <a href="https://medium.com/p/c1e5057a7ae6"><time class="dt-published" datetime="2023-08-30T17:04:40.008Z">August 30, 2023</time></a>.</p><p><a href="https://medium.com/@vadiminshakov/golang-design-generics-vs-interfaces-how-it-really-works-under-the-hood-c1e5057a7ae6" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on January 21, 2024.</p></footer></article></body></html>
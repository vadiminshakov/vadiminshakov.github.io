<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Пишем партиционированный кеш на go map (x3 быстрее стандартной map)</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Пишем партиционированный кеш на go map (x3 быстрее стандартной map)</h1>
</header>
<section data-field="subtitle" class="p-summary">
Представьте, что вы делаете inmemory-кеш, который должен работать под высокой нагрузкой. При этом основная нагрузка приходится на запись…
</section>
<section data-field="body" class="e-content">
<section name="2ae7" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="d91a" id="d91a" class="graf graf--h3 graf--leading graf--title">Пишем партиционированный кеш на go map (x3 быстрее стандартной map)</h3><figure name="8b8a" id="8b8a" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*wkaFh4Dy6A_gSnZCIBlr1Q.png" data-width="1024" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*wkaFh4Dy6A_gSnZCIBlr1Q.png"></figure><p name="63e8" id="63e8" class="graf graf--p graf-after--figure">Представьте, что вы делаете inmemory-кеш, который должен работать под высокой нагрузкой. При этом основная нагрузка приходится на запись. Для этой задачи отлично подходит go map, защищенная мьютексами.</p><p name="8994" id="8994" class="graf graf--p graf-after--p">Но что будет, если, скажем, ваш кеш работает на мощном сервере с 64-мя ядрами и ваш go-рантайм создает 64 потока, каждый из которых потенциально может обращаться к вашему кешу? В таком случае мы столкнемся с множественными системными вызовами и значительными задержками из-за блокировок: когда один поток записывает данные, остальные вынуждены ждать.</p><p name="3a18" id="3a18" class="graf graf--p graf-after--p">Решение: разделить go map на отдельные партиции или сегменты, каждый из которых будет блокироваться независимо от других. Это позволит каждому потоку обращаться к своей партиции без необходимости блокировать доступ к остальным, тем самым оптимизируя процесс записи и обеспечивая высокую производительность даже в условиях высокой нагрузки.</p><pre data-code-block-mode="2" spellcheck="false" data-code-block-lang="go" name="6c52" id="6c52" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> PartitionedMap <span class="hljs-keyword">struct</span> {<br />   partsnum   <span class="hljs-type">uint</span>           <span class="hljs-comment">// количество партиций</span><br />   partitions []*partition   <span class="hljs-comment">// сами партиции</span><br />   finder     partitioner    <span class="hljs-comment">// абстрактный поисковик партиций</span><br />}</span></pre><p name="0647" id="0647" class="graf graf--p graf-after--pre">Итак, мы будем хранить сами партиции, некий объект, позволяющий находить партиции для ключа, и количество партиций (как будет показано ниже, количество партиций нужно хранить, чтобы мэтчить ключи с патрициями).</p><p name="b75b" id="b75b" class="graf graf--p graf-after--p">Партиция — это отдельный мапа с мьютексом:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="f240" id="f240" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> partition <span class="hljs-keyword">struct</span> {<br />   stor <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]any<br />   sync.RWMutex<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *partition)</span></span> set(key <span class="hljs-type">string</span>, value any) {<br />   p.Lock()<br />   p.stor[key] = value<br />   p.Unlock()<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *partition)</span></span> get(key <span class="hljs-type">string</span>) (any, <span class="hljs-type">bool</span>) {<br />   p.RLock()<br />   v, ok := p.stor[key]<br />   <span class="hljs-keyword">if</span> !ok {<br />      p.RUnlock()<br />      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br />   }<br />   p.RUnlock()<br />   <span class="hljs-keyword">return</span> v, <span class="hljs-literal">true</span><br />}</span></pre><p name="ecd6" id="ecd6" class="graf graf--p graf-after--pre">Поисковик по партициям (partitioner) должен для каждого отдельного ключа возвращать индекс партиции:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="324e" id="324e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> partitioner <span class="hljs-keyword">interface</span> {<br />   Find(key <span class="hljs-type">string</span>) (<span class="hljs-type">uint</span>, <span class="hljs-type">error</span>)<br />}</span></pre><p name="f4f5" id="f4f5" class="graf graf--p graf-after--pre">Самый простой способ реализации этого интерфейса — алгоритм деления с остатком:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="d92a" id="d92a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> hashSumPartitioner <span class="hljs-keyword">struct</span> {<br />   partitionsNum <span class="hljs-type">uint</span><br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hashSumPartitioner)</span></span> Find(key <span class="hljs-type">string</span>) (<span class="hljs-type">uint</span>, <span class="hljs-type">error</span>) {<br />   hashSum := crc32.ChecksumIEEE([]<span class="hljs-type">byte</span>(key))<br /><br />   <span class="hljs-keyword">return</span> <span class="hljs-type">uint</span>(hashSum) % h.partitionsNum, <span class="hljs-literal">nil</span><br />}</span></pre><p name="8629" id="8629" class="graf graf--p graf-after--pre">Здесь для примера используется чексумма ключа crc32, но можно использовать любую функцию хеширования, главное чтобы она работала быстро. Полученное при хешировании значение делится на количество партиций и в итоге мы получаем индекс партиции, куда можно положить (или откуда можно достать) некоторый ключ.</p><p name="7192" id="7192" class="graf graf--p graf-after--p">Допустим, если у вас 3 партиции</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="710a" id="710a" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPartitionedMap</span><span class="hljs-params">(partitioner partitioner, partsnum <span class="hljs-type">uint</span>)</span></span> *PartitionedMap {<br />   partitions := <span class="hljs-built_in">make</span>([]*partition, <span class="hljs-number">0</span>, partsnum)<br />   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">int</span>(partsnum); i++ {<br />      m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]any)<br />      partitions = <span class="hljs-built_in">append</span>(partitions, &amp;partition{stor: m})<br />   }<br />   <span class="hljs-keyword">return</span> &amp;PartitionedMap{partsnum: partsnum, partitions: partitions, finder: partitioner}<br />}<br /><br />pm := NewPartitionedMap(partitionerImpl, <span class="hljs-number">3</span>)<br /><span class="hljs-comment">// pm internals:</span><br /><span class="hljs-comment">// {</span><br /><span class="hljs-comment">//   partsnum = 3         </span><br /><span class="hljs-comment">//   partitions = []*partition{part1, part2, part3}</span><br /><span class="hljs-comment">//   finder     partitioner = ...</span><br /><span class="hljs-comment">// }</span></span></pre><p name="6cce" id="6cce" class="graf graf--p graf-after--pre">И ваша функция хеширования для ключа <code class="markup--code markup--p-code">testkey</code>выдала 125, то мы найдем нужную партицию так <code class="markup--code markup--p-code">125%3=41 (остаток 2)</code> , следовательно, ключ <code class="markup--code markup--p-code">testkey</code>принадлежит партиции с индексом 2 (part2).</p><p name="2da2" id="2da2" class="graf graf--p graf-after--p">Теперь мы для любого ключа можем определить партицию:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="c370" id="c370" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *PartitionedMap)</span></span> Set(key <span class="hljs-type">string</span>, value any) <span class="hljs-type">error</span> {<br />   <span class="hljs-comment">// находим индекс партиции</span><br />   partitionIndex, err := c.finder.Find(key)<br />   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<br />      <span class="hljs-keyword">return</span> err<br />   }<br /><br />   <span class="hljs-comment">// достаем партицию из слайса</span><br />   partition := c.partitions[partitionIndex]<br />   <span class="hljs-comment">// записываем ключ в партицию</span><br />   partition.set(key, value)<br /><br />   <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br />}<br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *PartitionedMap)</span></span> Get(key <span class="hljs-type">string</span>) (any, <span class="hljs-type">error</span>) {<br />   partitionIndex, err := c.finder.Find(key)<br />   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<br />      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br />   }<br /><br />   partition := c.partitions[partitionIndex]<br />   value, ok := partition.get(key)<br />   <span class="hljs-keyword">if</span> !ok {<br />      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;no such data&quot;</span>)<br />   }<br /><br />   <span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br />}</span></pre><p name="ac0f" id="ac0f" class="graf graf--p graf-after--pre">Всё просто! Напишем бенчмарк, чтобы сравнить нашу реализацию со стандартной мапой.</p><p name="e4f9" id="e4f9" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">BenchmarckStd</code> — бенчмарк для стандартной мапы с мьютексом.</p><p name="bc77" id="bc77" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">BenchmarkSyncStd</code> — бенчмарк для sync.Map.</p><p name="7336" id="7336" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">BenchmarkPartiotioned</code> — бенчмарк партиционированной мапы.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="8dba" id="8dba" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkStd</span><span class="hljs-params">(b *testing.B)</span></span> {<br />   m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br />   b.Run(<span class="hljs-string">&quot;set std concurrently&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b *testing.B)</span></span> {<br />      <span class="hljs-keyword">var</span> wg sync.WaitGroup<br />      <span class="hljs-keyword">var</span> mu sync.RWMutex<br />      <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />         wg.Add(<span class="hljs-number">1</span>)<br />         i := i<br />         <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br />            mu.Lock()<br />            m[fmt.Sprint(i)] = i<br />            mu.Unlock()<br />            wg.Done()<br />         }()<br />      }<br />      wg.Wait()<br />   })<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSyncStd</span><span class="hljs-params">(b *testing.B)</span></span> {<br />   b.Run(<span class="hljs-string">&quot;set sync map std concurrently&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b *testing.B)</span></span> {<br />      <span class="hljs-keyword">var</span> m sync.Map<br />      <span class="hljs-keyword">var</span> wg sync.WaitGroup<br />      <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />         wg.Add(<span class="hljs-number">1</span>)<br />         i := i<br />         <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br />            m.Store(fmt.Sprint(i), i)<br />            wg.Done()<br />         }()<br />      }<br />      wg.Wait()<br />   })<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPartitioned</span><span class="hljs-params">(b *testing.B)</span></span> {<br />   m := NewPartitionedMap(&amp;hashSumPartitioner{<span class="hljs-number">1000</span>}, <span class="hljs-number">1000</span>)<br />   b.Run(<span class="hljs-string">&quot;set partitioned concurrently&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b *testing.B)</span></span> {<br />      <span class="hljs-keyword">var</span> wg sync.WaitGroup<br />      <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />         wg.Add(<span class="hljs-number">1</span>)<br />         i := i<br />         <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br />            m.Set(fmt.Sprint(i), i)<br />            wg.Done()<br />         }()<br />      }<br />      wg.Wait()<br />   })<br />}</span></pre><p name="97a8" id="97a8" class="graf graf--p graf-after--pre">Результаты (на 6-ядерном процессоре):</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="905c" id="905c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">go <span class="hljs-built_in">test</span> -bench=. -benchtime=3s<br /><br />goos: darwin<br />goarch: amd64<br />pkg: github.com/vadimInshakov/partmap<br />cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz<br /><br />BenchmarkStd/set_std_concurrently-12                  3289076   1332 ns/op<br />BenchmarkSyncStd/set_sync_map_std_concurrently-12     2408612   1691 ns/op<br />BenchmarkPartitioned/set_partitioned_concurrently-12  13536134  408.6 ns/op</span></pre><p name="18b1" id="18b1" class="graf graf--p graf-after--pre">Партиционированная мапа в <strong class="markup--strong markup--p-strong">3.25</strong> раз быстрее мапы на мьютексах и в 4.13 раз быстрее sync.Map.</p><p name="b8c6" id="b8c6" class="graf graf--p graf-after--p graf--trailing">Все исходники доступны здесь: <a href="https://github.com/vadimInshakov/partmap" data-href="https://github.com/vadimInshakov/partmap" class="markup--anchor markup--p-anchor" rel="nofollow noopener noopener" target="_blank">https://github.com/vadiminshakov/partmap</a></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@vadiminshakov" class="p-author h-card">Vadim Inshakov</a> on <a href="https://medium.com/p/41abcd21318d"><time class="dt-published" datetime="2023-08-10T15:38:46.133Z">August 10, 2023</time></a>.</p><p><a href="https://medium.com/@vadiminshakov/%D0%BF%D0%B8%D1%88%D0%B5%D0%BC-%D0%BF%D0%B0%D1%80%D1%82%D0%B8%D1%86%D0%B8%D0%BE%D0%BD%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%83%D1%8E-go-map-x3-%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%B5%D0%B5-%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%D0%BD%D0%BE%D0%B9-map-41abcd21318d" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on January 21, 2024.</p></footer></article></body></html>
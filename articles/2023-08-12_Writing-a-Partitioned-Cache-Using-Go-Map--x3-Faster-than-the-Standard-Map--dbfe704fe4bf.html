<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Writing a Partitioned Cache Using Go Map (x3 Faster than the Standard Map)</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Writing a Partitioned Cache Using Go Map (x3 Faster than the Standard Map)</h1>
</header>
<section data-field="subtitle" class="p-summary">
Imagine you’re making an in-memory cache that needs to operate under high load, with the primary load focused on writing. For this task, a…
</section>
<section data-field="body" class="e-content">
<section name="05e5" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="9d03" id="9d03" class="graf graf--h3 graf--leading graf--title">Writing a Partitioned Cache Using Go Map (x3 Faster than the Standard Map)</h3><figure name="a435" id="a435" class="graf graf--figure graf-after--h3"><img class="graf-image" data-image-id="1*y3HSIiJRa5UxtBFrczEv3Q.png" data-width="1024" data-height="1024" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*y3HSIiJRa5UxtBFrczEv3Q.png"></figure><p name="4c92" id="4c92" class="graf graf--p graf-after--figure">Imagine you’re making an in-memory cache that needs to operate under high load, with the primary load focused on writing. For this task, a go map protected by mutex is ideal.</p><p name="2a7d" id="2a7d" class="graf graf--p graf-after--p">But what if, say, your cache operates on a powerful server with 64 cores, and your go-runtime creates 64 threads, each of which can potentially access your cache? In such a case, we would face multiple system calls and significant delays due to locks: when one thread writes data, the others are forced to wait.</p><p name="5036" id="5036" class="graf graf--p graf-after--p">The solution: split the go map into separate partitions or segments, each of which will lock independently of the others. This allows each thread to access its partition without the need to lock access to the others, thus optimizing the writing process and ensuring high performance even under high load.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="a68c" id="a68c" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> PartitionedMap <span class="hljs-keyword">struct</span> {<br />   partsnum   <span class="hljs-type">uint</span>           <span class="hljs-comment">// partitions number</span><br />   partitions []*partition   <span class="hljs-comment">// partitions slice</span><br />   finder     partitioner    <span class="hljs-comment">// abstract partitions finder</span><br />}</span></pre><p name="5280" id="5280" class="graf graf--p graf-after--pre">So, we will store the partitions themselves, an object that allows finding partitions for a key, and the number of partitions (as will be shown below, we need to store the number of partitions to match keys with partitions).</p><p name="8893" id="8893" class="graf graf--p graf-after--p">A partition is a separate map with a mutex:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="96a1" id="96a1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> partition <span class="hljs-keyword">struct</span> {<br />   stor <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]any<br />   sync.RWMutex<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *partition)</span></span> set(key <span class="hljs-type">string</span>, value any) {<br />   p.Lock()<br />   p.stor[key] = value<br />   p.Unlock()<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *partition)</span></span> get(key <span class="hljs-type">string</span>) (any, <span class="hljs-type">bool</span>) {<br />   p.RLock()<br />   v, ok := p.stor[key]<br />   <span class="hljs-keyword">if</span> !ok {<br />      p.RUnlock()<br />      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span><br />   }<br />   p.RUnlock()<br />   <span class="hljs-keyword">return</span> v, <span class="hljs-literal">true</span><br />}</span></pre><p name="f090" id="f090" class="graf graf--p graf-after--pre">The partition finder (partitioner) should return the index of the partition for each individual key:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="15a6" id="15a6" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> partitioner <span class="hljs-keyword">interface</span> {<br />   Find(key <span class="hljs-type">string</span>) (<span class="hljs-type">uint</span>, <span class="hljs-type">error</span>)<br />}</span></pre><p name="55e1" id="55e1" class="graf graf--p graf-after--pre">The simplest way to implement this interface is the remainder division algorithm:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="ca41" id="ca41" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-keyword">type</span> hashSumPartitioner <span class="hljs-keyword">struct</span> {<br />   partitionsNum <span class="hljs-type">uint</span><br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h *hashSumPartitioner)</span></span> Find(key <span class="hljs-type">string</span>) (<span class="hljs-type">uint</span>, <span class="hljs-type">error</span>) {<br />   hashSum := crc32.ChecksumIEEE([]<span class="hljs-type">byte</span>(key))<br /><br />   <span class="hljs-keyword">return</span> <span class="hljs-type">uint</span>(hashSum) % h.partitionsNum, <span class="hljs-literal">nil</span><br />}</span></pre><p name="0b8e" id="0b8e" class="graf graf--p graf-after--pre">Here, for example, the crc32 checksum of the key is used, but any hash function can be used, as long as it works quickly. The value obtained from hashing is divided by the number of partitions, and as a result, we get the index of the partition where a certain key can be placed (or from where it can be retrieved).</p><p name="501c" id="501c" class="graf graf--p graf-after--p">Suppose you have 3 partitions:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="05b1" id="05b1" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPartitionedMap</span><span class="hljs-params">(partitioner partitioner, partsnum <span class="hljs-type">uint</span>)</span></span> *PartitionedMap {<br />   partitions := <span class="hljs-built_in">make</span>([]*partition, <span class="hljs-number">0</span>, partsnum)<br />   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-type">int</span>(partsnum); i++ {<br />      m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]any)<br />      partitions = <span class="hljs-built_in">append</span>(partitions, &amp;partition{stor: m})<br />   }<br />   <span class="hljs-keyword">return</span> &amp;PartitionedMap{partsnum: partsnum, partitions: partitions, finder: partitioner}<br />}<br /><br />pm := NewPartitionedMap(partitionerImpl, <span class="hljs-number">3</span>)<br /><span class="hljs-comment">// pm internals:</span><br /><span class="hljs-comment">// {</span><br /><span class="hljs-comment">//   partsnum = 3         </span><br /><span class="hljs-comment">//   partitions = []*partition{part1, part2, part3}</span><br /><span class="hljs-comment">//   finder     partitioner = ...</span><br /><span class="hljs-comment">// }</span></span></pre><p name="e8d2" id="e8d2" class="graf graf--p graf-after--pre">And if your hashing function for the key <code class="markup--code markup--p-code">testkey</code>yielded 125, then we would find the needed partition like this: <code class="markup--code markup--p-code">125%3=41</code> (remainder 2). Therefore, the key <code class="markup--code markup--p-code">testkey</code>belongs to the partition with index 2 (part2).</p><p name="ecff" id="ecff" class="graf graf--p graf-after--p">Now, for any key, we can determine the partition:</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="dd2e" id="dd2e" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *PartitionedMap)</span></span> Set(key <span class="hljs-type">string</span>, value any) <span class="hljs-type">error</span> {<br />   <span class="hljs-comment">// find partition index</span><br />   partitionIndex, err := c.finder.Find(key)<br />   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<br />      <span class="hljs-keyword">return</span> err<br />   }<br /><br />   <span class="hljs-comment">// get partition from slice</span><br />   partition := c.partitions[partitionIndex]<br />   <span class="hljs-comment">// write key to the partition</span><br />   partition.set(key, value)<br /><br />   <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br />}<br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *PartitionedMap)</span></span> Get(key <span class="hljs-type">string</span>) (any, <span class="hljs-type">error</span>) {<br />   partitionIndex, err := c.finder.Find(key)<br />   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {<br />      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br />   }<br /><br />   partition := c.partitions[partitionIndex]<br />   value, ok := partition.get(key)<br />   <span class="hljs-keyword">if</span> !ok {<br />      <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;no such data&quot;</span>)<br />   }<br /><br />   <span class="hljs-keyword">return</span> value, <span class="hljs-literal">nil</span><br />}</span></pre><p name="41b5" id="41b5" class="graf graf--p graf-after--pre">It’s simple! Let’s write a benchmark to compare our implementation with the standard map.</p><p name="7b06" id="7b06" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">BenchmarkStd</strong> — benchmark for the standard map with a mutex.</p><p name="9445" id="9445" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">BenchmarkSyncStd</strong> — benchmark for sync.Map.</p><p name="b63c" id="b63c" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">BenchmarkPartitioned</strong> — benchmark for the partitioned map.</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="go" name="0452" id="0452" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkStd</span><span class="hljs-params">(b *testing.B)</span></span> {<br />   m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br />   b.Run(<span class="hljs-string">&quot;set std concurrently&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b *testing.B)</span></span> {<br />      <span class="hljs-keyword">var</span> wg sync.WaitGroup<br />      <span class="hljs-keyword">var</span> mu sync.RWMutex<br />      <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />         wg.Add(<span class="hljs-number">1</span>)<br />         i := i<br />         <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br />            mu.Lock()<br />            m[fmt.Sprint(i)] = i<br />            mu.Unlock()<br />            wg.Done()<br />         }()<br />      }<br />      wg.Wait()<br />   })<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSyncStd</span><span class="hljs-params">(b *testing.B)</span></span> {<br />   b.Run(<span class="hljs-string">&quot;set sync map std concurrently&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b *testing.B)</span></span> {<br />      <span class="hljs-keyword">var</span> m sync.Map<br />      <span class="hljs-keyword">var</span> wg sync.WaitGroup<br />      <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />         wg.Add(<span class="hljs-number">1</span>)<br />         i := i<br />         <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br />            m.Store(fmt.Sprint(i), i)<br />            wg.Done()<br />         }()<br />      }<br />      wg.Wait()<br />   })<br />}<br /><br /><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPartitioned</span><span class="hljs-params">(b *testing.B)</span></span> {<br />   m := NewPartitionedMap(&amp;hashSumPartitioner{<span class="hljs-number">1000</span>}, <span class="hljs-number">1000</span>)<br />   b.Run(<span class="hljs-string">&quot;set partitioned concurrently&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(b *testing.B)</span></span> {<br />      <span class="hljs-keyword">var</span> wg sync.WaitGroup<br />      <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {<br />         wg.Add(<span class="hljs-number">1</span>)<br />         i := i<br />         <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {<br />            m.Set(fmt.Sprint(i), i)<br />            wg.Done()<br />         }()<br />      }<br />      wg.Wait()<br />   })<br />}</span></pre><p name="8f82" id="8f82" class="graf graf--p graf-after--pre">Results (on a 6-core processor):</p><pre data-code-block-mode="1" spellcheck="false" data-code-block-lang="bash" name="4ec3" id="4ec3" class="graf graf--pre graf-after--p graf--preV2"><span class="pre--content">go <span class="hljs-built_in">test</span> -bench=. -benchtime=3s<br /><br />goos: darwin<br />goarch: amd64<br />pkg: github.com/vadimInshakov/partmap<br />cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz<br /><br />BenchmarkStd/set_std_concurrently-12                  3289076   1332 ns/op<br />BenchmarkSyncStd/set_sync_map_std_concurrently-12     2408612   1691 ns/op<br />BenchmarkPartitioned/set_partitioned_concurrently-12  13536134  408.6 ns/op</span></pre><p name="8c55" id="8c55" class="graf graf--p graf-after--pre">The partitioned map is 3.25 times faster than the mutex-based map and 4.13 times faster than sync.Map.</p><p name="6528" id="6528" class="graf graf--p graf-after--p">All source code is available here:</p><p name="2138" id="2138" class="graf graf--p graf-after--p"><a href="https://github.com/vadimInshakov/partmap" data-href="https://github.com/vadimInshakov/partmap" class="markup--anchor markup--p-anchor" rel="noopener ugc nofollow noopener noopener" target="_blank">https://github.com/vadiminshakov/partmap</a></p><p name="5d49" id="5d49" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">You can support my work here: </em><a href="https://www.buymeacoffee.com/insh" data-href="https://www.buymeacoffee.com/insh" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">https://www.buymeacoffee.com/insh</em></strong></a></p><p name="64a0" id="64a0" class="graf graf--p graf-after--p graf--trailing"><em class="markup--em markup--p-em">Thank you for reading until the end. Please consider following the writer and this publication. Visit </em><a href="https://stackademic.com/" data-href="https://stackademic.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">Stackademic</em></strong></a><em class="markup--em markup--p-em"> to find out more about how we are democratizing free programming education around the world.</em></p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@vadiminshakov" class="p-author h-card">Vadim Inshakov</a> on <a href="https://medium.com/p/dbfe704fe4bf"><time class="dt-published" datetime="2023-08-12T09:35:40.245Z">August 12, 2023</time></a>.</p><p><a href="https://medium.com/@vadiminshakov/writing-a-partitioned-cache-using-go-map-x3-faster-than-the-standard-map-dbfe704fe4bf" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on January 21, 2024.</p></footer></article></body></html>